// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright (c) Microsoft Corporation. All rights reserved.
// 
//  File: MainWindow.xaml.cs 
//
//  This sample application demonstrates the following features of the 
//  Ink Analysis API and Ink in the Windows Presentation Foundation:
//  * Loading a scanned paper form (as an image in .png format)
//  * Using an InkCanvas to gather and display Ink over the scanned form
//  * Using an InkAnalyzer to interpret handwriting results
//  * Generating AnalysisHints to improve handwriting results
//  * Populating text boxes from analysis hints for a basic correction 
//    experience
// 
//-------------------------------------------------------------------------- 

using System;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Shapes;

// The System.Windows.Ink namespace contains 
// the Ink Analysis library for use with the 
// Windows Presentation Foundation
using System.Windows.Ink;

namespace Microsoft.Samples.TabletPC.InkAnalysisScannedPaperForm
{

    public partial class MainWindow : Window
    {
        // The Ink Analyzer object is the core of the handwriting API.
        private System.Windows.Ink.InkAnalyzer analyzer;

        // This collection of textBoxes will be updated with analysis 
        // results after analysis is completed.
        private System.Collections.Generic.List<TextBox> textBoxes;

        // These strings will be used with analysis hints to describe
        // the expected text for each field in the paper form.
        private static string[] factoidStrings =
        {
            // string for the "For:" Field
            // Indicates that we expect a full name
            "(!IS_PERSONALNAME_FULLNAME)",
            // string for the "Date:" Field
            // Indicates that we expect a complete date
            "(!IS_DATE_FULLDATE)",
            // string for the "Time:" Field
            // Indicates that we expect a complete time
            "(!IS_TIME_FULLTIME)",
            // string for the "From:" Field
            // Indicates that we expect a full name
            "(!IS_PERSONALNAME_FULLNAME)",
            // string for the "Phone Number:" hint
            // Indicates that we expect a phone number, 
            // including the area code
            "(!IS_TELEPHONENUMBER_FULLNUMBER)",
            // string for the "Message:" hint
            // We don't wat to specify any extra information,
            // since this field could contain anything, even
            // drawings
            "",
            // string for the "Taken by:" hint
            // Indicates that we expect a full name
            "(!IS_PERSONALNAME_FULLNAME)"
        };


        // Each rectangle in the rects array will be used for the bounds of an 
        // analysis hint.  
        private static Rect[] rects = 
        {            
            // Create a Rect for the "For:" field
            new Rect(117, 91, 470, 25),
            // Create a Rect for the "Date:" field
            new Rect(117, 128, 238, 25),
            // Create a Rect for the "Time:" field
            new Rect(465, 128, 122, 25),
            // Create a Rect for the "From:" field
            new Rect(117, 164, 470, 25),
            // Create a Rect for the "Phone Number:" field
            new Rect(270, 200, 317, 25),
            // Create a Rect for the "Message:" field
            new Rect(33, 305, 555, 230),
            // Create a Rect for the "Taken by:" field
            new Rect(192, 570, 396, 25)
        };


        public MainWindow()
        {
            // Autogenerated UI Initialization code which instantiates and 
            // builds the UI.
            InitializeComponent();

            // Create a new InkAnalyzer.  
            this.analyzer = new InkAnalyzer(this.Dispatcher);

            // Initialize programatically generated UI Elements (hint
            // rectangles and text boxes).
            this.Loaded += new RoutedEventHandler(MainWindowLoaded);
        }

        /// <summary>
        /// Event handler for the TabControl SelectionChanged event.
        /// </summary>
        void TabControlSelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            // If the user navigates to the second tab by clicking on the tab control,
            // invoke an analysis to update the results.
            if (this.tabControl.SelectedIndex == 1)
            {
                this.analyzer.Analyze();
                this.UpdateTextBoxes();
            }
        }

        /// <summary>
        /// Add Additional UI elements after the Window has been initialized.
        /// </summary>
        void MainWindowLoaded(object sender, RoutedEventArgs e)
        {
            // Create and position the UI Elements that we'll use to visually 
            // represent the Rectangles in the rects array.  This is purely
            // for visual reference, and not neccessary for building and 
            // using analysis hints.
            this.InitRectangles();

            // Create the analysis hints that will be used to give the program
            // information about how to group strokes.  Also, initialize the 
            // text boxes where analysis hints will be stored.
            this.InitHints();
        }


        /// <summary>
        /// Set up a fixed set of Rectangles positioned over the Image 
        /// where we expect users to ink
        /// </summary>
        private void InitRectangles()
        {

            // Create Rectangles for drawing (by adding directly to the 
            // ink canvas), based on the rects we just created
            foreach (Rect rect in rects)
            {

                // Create a new Rectangle 
                Rectangle rectangle = new Rectangle();

                // Make it the same size as the corresponding Rect
                rectangle.Width = rect.Width;
                rectangle.Height = rect.Height;

                // Since the position for Rectangles is handled 
                // through the Canvas they are hosted in, we need to 
                // use a static method on the InkCanvas class to set the 
                // position where they will be drawn.
                System.Windows.Controls.InkCanvas.SetTop(rectangle, rect.Top);
                System.Windows.Controls.InkCanvas.SetLeft(rectangle, rect.Left);

                // Set rectangle to be painted red and partially
                // transparent
                rectangle.Fill = new SolidColorBrush(Colors.Red);
                rectangle.Opacity = 0.25;

                // Set rectangle to be hidden initially.
                rectangle.Visibility = Visibility.Hidden;

                // Add rectangle to the InkCanvas
                this.inkCanvas.Children.Add(rectangle);
            }

        }

        /// <summary>
        /// When a stroke is collected, add it to the InkAnalyzer. 
        /// After a Stroke has been added, it will be analyzed 
        /// the next time BackgroundAnalyze or Analyze is called
        /// </summary>
        void StrokeCollected(object sender,
                        InkCanvasStrokeCollectedEventArgs e)
        {
            this.analyzer.AddStroke(e.Stroke);
        }

        /// <summary>
        /// Generate a text box based on a given analysis hint
        /// </summary>
        private TextBox InitTextBox(AnalysisHintNode hint)
        {
            // Get the bounds of the AnalysisHintNode
            Rect hintBounds = hint.Location.GetBounds();

            // Instantiate a new TextBox
            TextBox textBox = new TextBox();

            // Set the dimensions of the TextBox
            // to the dimensions of the hint
            textBox.Width = hintBounds.Width;
            textBox.Height = hintBounds.Height;

            // Set the location of the TextBox to 
            // the location of the hint
            Canvas.SetLeft(textBox, hintBounds.Left);
            Canvas.SetTop(textBox, hintBounds.Top);

            // Add the hint to the Canvas in the second 
            // TabbedPane
            this.textBoxCanvas.Children.Add(textBox);

            // Return a reference to the TextBox
            return textBox;
        }

        /// <summary>
        /// Create analysis hints for each area of the scanned 
        /// paper form.
        /// </summary>
        private void InitHints()
        {
            // Instantiate the collection of TextBoxes
            this.textBoxes = new System.Collections.Generic.List<TextBox>();

            // For each rectangle in rects
            for (int i = 0; i < rects.Length; i++)
            {

                Rect rectangle = rects[i];

                // Create an AnalysisHint with the bounds of the rectangle.  The bounds
                // of an AnalysisHint gives clues to the handwriting recognizer about
                // the way Strokes are grouped together.
                AnalysisHintNode hint = this.analyzer.CreateAnalysisHint(rectangle);

                // Set the corresponding factoid on the hint.  This gives the 
                // recognizer clues about the meaning of the strokes within the 
                // AnalysisHint's region
                hint.Factoid = factoidStrings[i];

                // Create a corresponding text box where the results of the analysis
                // associated with this hint will be displayed.  Store the reference
                // to the TextBox in the textBoxes Collection.
                this.textBoxes.Add(InitTextBox(hint));
            }
        }

        /// <summary>
        /// Update each TextBox if analysis results exist for the corresponding hint
        /// </summary>
        private void UpdateTextBoxes()
        {
            // Get the hints that we previously added to the analyzer.
            ContextNodeCollection hints = this.analyzer.GetAnalysisHints();

            for (int i = 0; i < hints.Count; i++)
            {
                // Get the recognized string from the hint
                string analyzedString = ((AnalysisHintNode)hints[i]).GetRecognizedString();

                // If we found a string, set the contents of the TextBox
                // to that string.
                if (analyzedString != null)
                {
                    this.textBoxes[i].Text = analyzedString;
                }
            }

        }

        /// <summary>
        /// When the clear button is clicked, we want to remove all
        /// Strokes from the InkCanvas and InkAnalyzer.
        /// </summary>
        void ClearButtonClicked(object sender, RoutedEventArgs e)
        {
            if (this.inkCanvas.Strokes.Count > 0)
            {
                // Remove the strokes from the Ink Analyzer
                this.analyzer.RemoveStrokes(this.inkCanvas.Strokes);

                // Remove the strokes from the Ink Canvas
                this.inkCanvas.Strokes.Clear();
            }
        }

        /// <summary>
        /// When the Analyze Button is clicked, we update the text boxes
        /// and switch to the text box tab item
        /// </summary>
        void AnalyzeButtonClicked(object sender, RoutedEventArgs e)
        {
            // Analyze the strokes that have been added to the analyzer.
            analyzer.Analyze();

            // Populate the text boxes with the results of the analysis.
            this.UpdateTextBoxes();

            // Navigate to the TabbedPane that contains the TextBoxes
            this.tabControl.SelectedIndex = 1;
        }

        /// <summary>
        /// Hide all of the Rectangles used to display the location of
        /// the AnalysisHints over the InkCanvas.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void Unchecked(object sender, RoutedEventArgs e)
        {
            // Set the visibility of all of the UIElement rectangles
            // used to display the location of the AnalysisHints to Hidden.
            this.SetCheckboxVisibility(Visibility.Hidden);
        }

        /// <summary>
        /// Show all of the Rectangles used to display the location of
        /// the AnalysisHints over the InkCanvas.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void Checked(object sender, RoutedEventArgs e)
        {
            // Set the visibility of all of the UIElement rectangles
            // used to display the location of the AnalysisHints to Visible.
            this.SetCheckboxVisibility(Visibility.Visible);
        }

        /// <summary>
        /// Set the visibility for every Rectangle that is a child of this InkCanvas.
        /// </summary>
        /// <param name="v">The visibility that will be set on each Rectangle</param>
        private void SetCheckboxVisibility(Visibility v)
        {
            // Set the visibility for every rectangle that is a 
            // child of the InkCanvas to be visible or hidden, 
            // We assume that no other rectangles are children
            // of the InkCanvas            
            foreach (UIElement child in this.inkCanvas.Children)
            {
                if (child is Rectangle)
                {
                    child.Visibility = v;
                }
            }
        }

        /// <summary>
        /// Clean up the resources for the application
        /// </summary>
        /// <param name="e"></param>
        protected override void OnClosed(EventArgs e)
        {
            // You must call analyzer.Dispose() to clean up
            // resources (both managed and unmanaged).
            this.analyzer.Dispose();
        }
    }
}